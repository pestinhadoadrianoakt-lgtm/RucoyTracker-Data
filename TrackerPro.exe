import customtkinter as ctk
import requests
from bs4 import BeautifulSoup
import re
import time
import pyautogui
import threading
from getmac import get_mac_address as gma
from datetime import datetime
import keyboard
import pygetwindow as gw
import ctypes
from ctypes import wintypes
import win32gui
import os
import subprocess
import sys

# ==================== CONTROLE DE VERS츾O ====================
VERSION = "1.0"  # <--- MUDE AQUI QUANDO FIZER UPDATE
# ============================================================

# JSONBIN
JSONBIN_BIN_ID = "6928968043b1c97be9c91e31"
JSONBIN_API_KEY = "$2a$10$si.gextI2G/dmDyvQwETsuh.jxPbVH6kwEA0FbJwATriFdlhTHL.q"
LICENSE_SERVER_URL = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}"

# ARQUIVOS
UPDATER_EXE = "Updater.exe"

# =========================================================
# CONFIGURA칂칏ES E ENGINE (MANTIDOS IGUAIS)
# =========================================================
KEY_MAP = {
    "Tracker": {"rx": 0.58958, "ry": 0.05925},
    "Name": {"rx": 0.48333, "ry": 0.72098},
    "Q": {"rx": 0.14444, "ry": 0.44938}, "W": {"rx": 0.22222, "ry": 0.45679}, "E": {"rx": 0.30000, "ry": 0.45432}, 
    "R": {"rx": 0.38055, "ry": 0.46172}, "T": {"rx": 0.45833, "ry": 0.46419}, "Y": {"rx": 0.53611, "ry": 0.46172}, 
    "U": {"rx": 0.61250, "ry": 0.45185}, "I": {"rx": 0.69305, "ry": 0.46172}, "O": {"rx": 0.77361, "ry": 0.46172}, 
    "P": {"rx": 0.85000, "ry": 0.45679}, "A": {"rx": 0.18333, "ry": 0.59506}, "S": {"rx": 0.26250, "ry": 0.59259}, 
    "D": {"rx": 0.34444, "ry": 0.60987}, "F": {"rx": 0.41805, "ry": 0.59753}, "G": {"rx": 0.49583, "ry": 0.60246}, 
    "H": {"rx": 0.57500, "ry": 0.59506}, "J": {"rx": 0.65694, "ry": 0.60246}, "K": {"rx": 0.72777, "ry": 0.59506}, 
    "L": {"rx": 0.80555, "ry": 0.59506}, "Z": {"rx": 0.26388, "ry": 0.73580}, "X": {"rx": 0.34166, "ry": 0.73086}, 
    "C": {"rx": 0.41111, "ry": 0.74074}, "V": {"rx": 0.49166, "ry": 0.74074}, "B": {"rx": 0.57500, "ry": 0.73827}, 
    "N": {"rx": 0.65000, "ry": 0.73827}, "M": {"rx": 0.73194, "ry": 0.74074}, 
    "Espa칞o": {"rx": 0.49305, "ry": 0.87160},
    "OK": {"rx": 0.80833, "ry": 0.31111}
}

STANDARD_GUILDS = {
    "Revenge Of The Fallens": "https://www.rucoyonline.com/guild/Revenge%20Of%20The%20Fallens",
    "Infernal Cruelty": "https://www.rucoyonline.com/guild/Infernal%20Cruelty",
    "Glory Hill": "https://www.rucoyonline.com/guild/Glory%20Hill"
}

try:
    ctypes.windll.shcore.SetProcessDpiAwareness(1)
except:
    ctypes.windll.user32.SetProcessDPIAware()

pyautogui.PAUSE = 0.025

class GameEngine:
    @staticmethod
    def get_render_area(main_title):
        try:
            wins = gw.getWindowsWithTitle(main_title)
            if not wins: return None
            main_hwnd = wins[0]._hWnd
            child_windows = []
            def enum_child_proc(hwnd, lParam):
                if win32gui.IsWindowVisible(hwnd):
                    rect = win32gui.GetWindowRect(hwnd)
                    w, h = rect[2] - rect[0], rect[3] - rect[1]
                    if w > 50 and h > 50:
                        child_windows.append((hwnd, w * h))
                return True
            win32gui.EnumChildWindows(main_hwnd, enum_child_proc, None)
            if child_windows:
                child_windows.sort(key=lambda x: x[1], reverse=True)
                target_hwnd = child_windows[0][0]
            else:
                target_hwnd = main_hwnd
            rect = wintypes.RECT()
            ctypes.windll.user32.GetClientRect(target_hwnd, ctypes.byref(rect))
            point = wintypes.POINT(0, 0)
            ctypes.windll.user32.ClientToScreen(target_hwnd, ctypes.byref(point))
            return point.x, point.y, rect.right, rect.bottom, wins[0]
        except Exception as e:
            print(f"Erro Engine: {e}")
            return None

def get_unique_id():
    mac = gma()
    return mac.upper() if mac else None

def scrape_players(url):
    try:
        match = re.search(r"guild/([^/]+)", url)
        guild_name = match.group(1).replace("%20", " ") if match else "Unknown"
        resp = requests.get(url)
        if resp.status_code != 200: return []
        soup = BeautifulSoup(resp.text, "html.parser")
        players = []
        for tr in soup.select("table tr"):
            if "Online" not in tr.get_text(): continue
            cols = tr.find_all("td")
            if len(cols) < 2: continue
            name = cols[0].get_text(" ", strip=True).replace("Online", "").strip()
            name = re.sub(r"Supporter|Support", "", name, flags=re.IGNORECASE).strip()
            level = cols[1].get_text(strip=True)
            players.append({"name": name, "level": level, "guild": guild_name})
        return players
    except:
        return []

# =========================================================
# L칍GICA DE LOGIN E UPDATE (ATUALIZADA)
# =========================================================
class MainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(f"Tracker Pro v{VERSION}")
        self.geometry("350x450")
        self.resizable(False, False)
        
        self.container = ctk.CTkFrame(self)
        self.container.pack(fill="both", expand=True)
        
        self.current_user = None
        self.current_username = None
        
        # Verifica Updater na inicializa칞칚o (Se n칚o tiver, tenta baixar)
        self.bootstrap_updater()
        
        self.show_login()

    def bootstrap_updater(self):
        # Se o Updater n칚o existe, baixa ele silenciosamente antes de come칞ar
        if not os.path.exists(UPDATER_EXE):
            threading.Thread(target=self._download_updater_thread).start()

    def _download_updater_thread(self):
        try:
            headers = {"X-Master-Key": JSONBIN_API_KEY}
            resp = requests.get(f"{LICENSE_SERVER_URL}/latest", headers=headers)
            config = resp.json().get('record', {}).get('config', {})
            
            token = config.get('github_token')
            url = config.get('updater_url')
            
            if token and url:
                gh_headers = {"Authorization": f"token {token}", "Accept": "application/vnd.github.v3.raw"}
                r = requests.get(url, headers=gh_headers)
                with open(UPDATER_EXE, "wb") as f:
                    f.write(r.content)
        except:
            pass 

    def show_login(self):
        for widget in self.container.winfo_children(): widget.destroy()
        frame = ctk.CTkFrame(self.container)
        frame.pack(pady=40, padx=40, fill="both", expand=True)
        ctk.CTkLabel(frame, text="TRACKER PRO", font=("Roboto", 24, "bold")).pack(pady=20)
        self.user_entry = ctk.CTkEntry(frame, placeholder_text="Usu치rio")
        self.user_entry.pack(pady=10, fill="x", padx=20)
        self.pass_entry = ctk.CTkEntry(frame, placeholder_text="Senha", show="*")
        self.pass_entry.pack(pady=10, fill="x", padx=20)
        self.btn_login = ctk.CTkButton(frame, text="ENTRAR", command=self.do_login, fg_color="#1abc9c", hover_color="#16a085")
        self.btn_login.pack(pady=20, fill="x", padx=20)
        self.lbl_msg = ctk.CTkLabel(frame, text="", text_color="red")
        self.lbl_msg.pack()

    def do_login(self):
        user = self.user_entry.get().strip()
        pwd = self.pass_entry.get().strip()
        self.btn_login.configure(state="disabled", text="Verificando...")
        threading.Thread(target=self.verify_login, args=(user, pwd)).start()

    def verify_login(self, username, password):
        try:
            mac = get_unique_id()
            headers = {"X-Master-Key": JSONBIN_API_KEY}
            resp = requests.get(f"{LICENSE_SERVER_URL}/latest", headers=headers)
            full_record = resp.json().get('record', {})
            
            # 1. Checa Vers칚o
            config = full_record.get('config', {})
            server_version = config.get('current_version', '1.0')
            
            if server_version > VERSION:
                self.after(0, lambda: self.prompt_update(server_version))
                return

            # 2. Checa Usu치rio
            users = full_record.get('users', [])
            valid_user = None
            for u in users:
                if u.get("username") == username and u.get("password") == password:
                    valid_user = u
                    break
            
            # 3. Valida Licen칞a
            if valid_user and valid_user.get("is_active"):
                # Checa data
                expiry = valid_user.get('expiry_date', '2000-01-01')
                try:
                    exp_date = datetime.strptime(expiry, "%Y-%m-%d")
                    if datetime.now() > exp_date:
                        self.after(0, lambda: self.fail_login("Licen칞a expirada! Contate o admin."))
                        return
                except:
                    self.after(0, lambda: self.fail_login("Erro na data da licen칞a."))
                    return

                # Checa HWID (MAC)
                saved_mac = valid_user.get('mac_address')
                if saved_mac and saved_mac != mac:
                    self.after(0, lambda: self.fail_login("HWID Incompat칤vel. Reset necess치rio."))
                    return
                
                # Se MAC for null, grava o atual (Primeiro login ou ap칩s reset)
                if not saved_mac:
                    valid_user['mac_address'] = mac
                    # Salva essa mudan칞a
                    for i, u in enumerate(users):
                        if u['username'] == username:
                            users[i] = valid_user
                            break
                    full_record['users'] = users
                    requests.put(LICENSE_SERVER_URL, headers={"Content-Type": "application/json", "X-Master-Key": JSONBIN_API_KEY}, json=full_record)

                self.current_user = valid_user
                self.current_username = username
                self.after(0, self.show_tracker)
            else:
                self.after(0, lambda: self.fail_login("Dados inv치lidos."))
                
        except Exception as e:
            self.after(0, lambda: self.fail_login(f"Erro: {e}"))

    def prompt_update(self, new_ver):
        self.lbl_msg.configure(text=f"Nova vers칚o {new_ver} dispon칤vel!", text_color="yellow")
        self.btn_login.configure(text="ATUALIZAR AGORA", command=self.launch_updater, fg_color="#e67e22", state="normal")

    def launch_updater(self):
        if os.path.exists(UPDATER_EXE):
            subprocess.Popen([UPDATER_EXE])
            self.destroy() # Fecha o bot
        else:
            self.lbl_msg.configure(text="Updater.exe n칚o encontrado!", text_color="red")

    def fail_login(self, msg):
        self.lbl_msg.configure(text=msg)
        self.btn_login.configure(state="normal", text="ENTRAR")

    def show_tracker(self):
        self.geometry("600x700")
        self.resizable(True, True)
        self.title(f"Tracker Pro - {self.current_username} (Expira: {self.current_user.get('expiry_date')})")
        for widget in self.container.winfo_children(): widget.destroy()
        TrackerFrame(self.container, self.current_user, self.current_username).pack(fill="both", expand=True)

# O RESTO DA CLASSE TrackerFrame (Igual ao anterior)
class TrackerFrame(ctk.CTkFrame):
    def __init__(self, master, user_data, username):
        super().__init__(master)
        self.user_data = user_data
        self.username = username
        self.target_window = "Nenhuma Selecionada"
        self.running = False
        self.guilds = STANDARD_GUILDS.copy()
        if 'custom_guilds' in self.user_data:
            self.guilds.update(self.user_data['custom_guilds'])
        self.setup_ui()

    def setup_ui(self):
        top_frame = ctk.CTkFrame(self)
        top_frame.pack(pady=10, padx=20, fill="x")
        self.lbl_window = ctk.CTkLabel(top_frame, text=f"Alvo: {self.target_window}", text_color="#f39c12", font=("Roboto", 14, "bold"))
        self.lbl_window.pack(side="left", padx=10)
        ctk.CTkButton(top_frame, text="游댌 Selecionar Janela (3s)", command=self.select_window_thread, width=150).pack(side="right", padx=10, pady=10)
        ctk.CTkLabel(self, text="Guildas Dispon칤veis:", font=("Roboto", 14)).pack(pady=(10,0))
        self.scroll_guilds = ctk.CTkScrollableFrame(self, height=200)
        self.scroll_guilds.pack(pady=5, padx=20, fill="x")
        self.guild_vars = {}
        self.refresh_guild_list()
        add_frame = ctk.CTkFrame(self)
        add_frame.pack(pady=10, padx=20, fill="x")
        self.entry_guild_url = ctk.CTkEntry(add_frame, placeholder_text="URL da Guilda")
        self.entry_guild_url.pack(side="left", fill="x", expand=True, padx=5, pady=5)
        ctk.CTkButton(add_frame, text="+", width=40, command=self.add_guild).pack(side="right", padx=5)
        self.btn_start = ctk.CTkButton(self, text="INICIAR (F9)", command=self.toggle_tracking, fg_color="#2ecc71", height=50, font=("Roboto", 16, "bold"))
        self.btn_start.pack(pady=10, padx=40, fill="x")
        self.log_box = ctk.CTkTextbox(self, height=150, state="disabled")
        self.log_box.pack(pady=10, padx=20, fill="both", expand=True)

    def refresh_guild_list(self):
        for widget in self.scroll_guilds.winfo_children(): widget.destroy()
        self.guild_vars = {}
        saved_selections = self.user_data.get('selected_guilds', [])
        for name, url in self.guilds.items():
            var = ctk.BooleanVar(value=name in saved_selections)
            self.guild_vars[name] = var
            chk = ctk.CTkCheckBox(self.scroll_guilds, text=name, variable=var)
            chk.pack(anchor="w", pady=2)

    def select_window_thread(self):
        self.lbl_window.configure(text="Clique na janela em 3s...", text_color="cyan")
        self.update()
        threading.Thread(target=self._window_logic).start()

    def _window_logic(self):
        time.sleep(3)
        try:
            win = gw.getActiveWindow()
            if win:
                self.target_window = win.title
                self.lbl_window.configure(text=f"Alvo: {self.target_window}", text_color="#2ecc71")
                self.log(f"Alvo: {self.target_window}")
            else:
                self.lbl_window.configure(text="Falha ao detectar", text_color="red")
        except:
             self.lbl_window.configure(text="Erro API Janela", text_color="red")

    def log(self, text):
        self.log_box.configure(state="normal")
        self.log_box.insert("end", f"[{datetime.now().strftime('%H:%M:%S')}] {text}\n")
        self.log_box.see("end")
        self.log_box.configure(state="disabled")

    def add_guild(self):
        url = self.entry_guild_url.get().strip()
        match = re.search(r"guild/([^/]+)", url)
        if match:
            name = match.group(1).replace("%20", " ")
            if 'custom_guilds' not in self.user_data: self.user_data['custom_guilds'] = {}
            self.user_data['custom_guilds'][name] = url
            self.guilds[name] = url
            self.refresh_guild_list()
            self.entry_guild_url.delete(0, "end")
            self.log(f"Guilda '{name}' adicionada localmente.")
        else:
            self.log("URL inv치lida.")

    def toggle_tracking(self):
        if self.running: return
        selected = [name for name, var in self.guild_vars.items() if var.get()]
        if not selected:
            self.log("Nenhuma guilda!")
            return
        if self.target_window == "Nenhuma Selecionada":
            self.log("Selecione a janela!")
            return
        self.user_data['selected_guilds'] = selected
        self.running = True
        self.btn_start.configure(text="RODANDO... (ESC PARA PARAR)", fg_color="#e74c3c", state="disabled")
        threading.Thread(target=self.run_logic, args=(selected,)).start()

    def run_logic(self, selected_guilds_names):
        try:
            urls = [self.guilds[n] for n in selected_guilds_names]
            self.log("Coletando jogadores...")
            players = []
            seen = set()
            for url in urls:
                p_list = scrape_players(url)
                for p in p_list:
                    if p['name'] not in seen:
                        players.append(p)
                        seen.add(p['name'])
            self.log(f"{len(players)} jogadores encontrados.")
            time.sleep(2)
            area = GameEngine.get_render_area(self.target_window)
            if not area:
                self.log("Janela n칚o encontrada!")
                return
            gx, gy, gw_sz, gh_sz, win_obj = area
            try: win_obj.activate()
            except: pass
            
            def click_btn(key_name):
                if key_name not in KEY_MAP: return
                c = KEY_MAP[key_name]
                tx = gx + (c['rx'] * gw_sz)
                ty = gy + (c['ry'] * gh_sz)
                pyautogui.moveTo(tx, ty, duration=0)
                pyautogui.click()

            for p in players:
                if keyboard.is_pressed('esc'):
                    self.log("Parada (ESC).")
                    break
                self.log(f"Search: {p['name']}")
                click_btn("Tracker")
                click_btn("Name")
                last_char = ""
                for char in p['name'].lower():
                    key = "Espa칞o" if char == " " else char.upper()
                    if key == last_char: time.sleep(0.05)
                    click_btn(key)
                    last_char = key
                    time.sleep(0.01)
                click_btn("OK")
                time.sleep(0.08)
                click_btn("Tracker")
            self.log("Finalizado.")
        except Exception as e:
            self.log(f"Erro: {e}")
        finally:
            self.running = False
            self.btn_start.configure(text="INICIAR (F9)", fg_color="#2ecc71", state="normal")

if __name__ == "__main__":
    app = MainApp()
    app.mainloop()
